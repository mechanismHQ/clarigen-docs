"use strict";(self.webpackChunkheynky=self.webpackChunkheynky||[]).push([[748],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294),r=n(4334);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(7462),r=n(7294),i=n(4334),o=n(2389),l=n(7392),s=n(7094),c=n(2466);const u="tabList__CuJ",p="tabItem_LNqP";function d(e){var t;const{lazy:n,block:o,defaultValue:d,values:m,groupId:h,className:k}=e,f=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=m??f.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),y=(0,l.l)(g,((e,t)=>e.value===t.value));if(y.length>0)throw new Error(`Docusaurus error: Duplicate values "${y.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===d?d:d??(null==(t=f.find((e=>e.props.default)))?void 0:t.props.value)??f[0].props.value;if(null!==v&&!g.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:b,setTabGroupChoices:C}=(0,s.U)(),[N,x]=(0,r.useState)(v),w=[],{blockElementScrollPositionUntilNextRender:O}=(0,c.o5)();if(null!=h){const e=b[h];null!=e&&e!==N&&g.some((t=>t.value===e))&&x(e)}const E=e=>{const t=e.currentTarget,n=w.indexOf(t),a=g[n].value;a!==N&&(O(t),x(a),null!=h&&C(h,String(a)))},T=e=>{var t;let n=null;switch(e.key){case"Enter":E(e);break;case"ArrowRight":{const t=w.indexOf(e.currentTarget)+1;n=w[t]??w[0];break}case"ArrowLeft":{const t=w.indexOf(e.currentTarget)-1;n=w[t]??w[w.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",u)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},k)},g.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>w.push(e),onKeyDown:T,onClick:E},o,{className:(0,i.Z)("tabs__item",p,null==o?void 0:o.className,{"tabs__item--active":N===t})}),n??t)}))),n?(0,r.cloneElement)(f.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function m(e){const t=(0,o.Z)();return r.createElement(d,(0,a.Z)({key:String(t)},e))}},9411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),i=n(5488),o=n(5162);const l={sidebar_label:"Deno (Clarinet tests)",toc_max_heading_level:4},s="Clarinet Unit Tests",c={unversionedId:"deno",id:"deno",title:"Clarinet Unit Tests",description:"If you're using Clarinet during contract development, you're probably using clarinet test to write unit tests for your contracts. Clarigen is designed to work alongside Clarinet; in fact, Clarigen is built on top of Clarinet!",source:"@site/docs/deno.md",sourceDirName:".",slug:"/deno",permalink:"/docs/deno",draft:!1,tags:[],version:"current",frontMatter:{sidebar_label:"Deno (Clarinet tests)",toc_max_heading_level:4},sidebar:"clarigen",previous:{title:"Write tests with Clarigen",permalink:"/docs/write-tests-tutorial"},next:{title:"Configuration",permalink:"/docs/configuration"}},u={},p=[{value:"Getting started",id:"getting-started",level:2},{value:"Importing Clarigen in Deno",id:"importing-clarigen-in-deno",level:2},{value:"Example",id:"example",level:2},{value:"Differences between Clarigen and Clarinet",id:"differences-between-clarigen-and-clarinet",level:2},{value:"API",id:"api",level:2},{value:"<code>contractsFactory</code>",id:"contractsfactory",level:3},{value:"<code>factory</code>",id:"factory",level:3},{value:"<code>chain</code>",id:"chain",level:3},{value:"Transaction builders (<code>tx</code>, <code>txOk</code>, and <code>txErr</code>)",id:"tx-builders",level:3},{value:"<code>chain.mineBlock</code>",id:"chainmineblock",level:3},{value:"<code>chain.mine</code>",id:"chainmine",level:3},{value:"<code>chain.mineOne</code>",id:"chainmineone",level:3},{value:"<code>chain.tx</code>, <code>chain.txOk</code>, and <code>chain.txErr</code>",id:"chaintx-chaintxok-and-chaintxerr",level:3},{value:"Read-only function calls",id:"read-only-function-calls",level:3},{value:"<code>chain.ro</code>",id:"chainro",level:4},{value:"<code>chain.rov</code>",id:"chainrov",level:4},{value:"<code>chain.rovOk</code> and <code>chain.rovErr</code>",id:"chainrovok-and-chainroverr",level:4},{value:"Accounts",id:"accounts",level:3},{value:"<code>Chain.fromSimnet</code>",id:"chainfromsimnet",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"clarinet-unit-tests"},"Clarinet Unit Tests"),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/hirosystems/clarinet"},"Clarinet")," during contract development, you're probably using ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet test")," to write unit tests for your contracts. Clarigen is designed to work alongside Clarinet; in fact, Clarigen is built on top of Clarinet!"),(0,r.kt)("h2",{id:"getting-started"},"Getting started"),(0,r.kt)("p",null,"To use Clarigen in Deno, make sure you've followed the ",(0,r.kt)("a",{parentName:"p",href:"./getting-started"},"getting started")," guide. Additionally, you'll need to specify ",(0,r.kt)("a",{parentName:"p",href:"./configuration#deno"},(0,r.kt)("inlineCode",{parentName:"a"},"deno.output")," configuration"),". In these examples, it's assumed that the Clarigen auto-generated code is at ",(0,r.kt)("inlineCode",{parentName:"p"},"./tests/clarigen.ts"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="Clarigen.toml"',title:'"Clarigen.toml"'},'[deno]\noutput = "tests/clarigen.ts"\n')),(0,r.kt)("h2",{id:"importing-clarigen-in-deno"},"Importing Clarigen in Deno"),(0,r.kt)("p",null,"Clarigen's Deno package is published to ",(0,r.kt)("a",{parentName:"p",href:"https://deno.land"},"deno.land"),", so you can import Clarigen from there:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import * as Clarigen from "https://deno.land/x/clarigen/src/index.ts";\n')),(0,r.kt)("p",null,"In the above example, a version of the package isn't specified, so the latest version will be used. As a best practice, you should specify the version of the package you're using. When getting setup, visit the ",(0,r.kt)("a",{parentName:"p",href:"https://deno.land/x/clarigen"},"Clarigen package page")," to see the latest version. You can learn more in the ",(0,r.kt)("a",{parentName:"p",href:"https://deno.land/manual/examples/manage_dependencies"},"Deno docs for managing dependencies"),"."),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"Here's an example of a basic (but complete) contract test using Clarigen and Clarinet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tests/contract_test.ts"',title:'"tests/contract_test.ts"'},'// import from the Clarigen package:\nimport { factory, txOk } from "https://deno.land/x/clarigen/src/index.ts";\n// import from your auto-generated code:\nimport { simnet } from "./clarigen.ts";\nimport { assertEquals } from "https://deno.land/std@0.90.0/testing/asserts.ts";\n\n// helper function to "setup" the test environment\nconst { contracts, test } = factory(simnet);\n\n// "counter" is the name of our contract\nconst { counter } = contracts;\n\ntest({\n  name: "Counter test",\n  fn(chain, accounts) {\n    // similar to `accounts.get(\'wallet_1\').address`;\n    const alice = accounts.addr("wallet_1");\n\n    // mine a block with a single transaction\n    // similar to `const [receipt] = chain.mineBlock(...).receipts;`\n    const receipt = chain.mineOne(txOk(counter.increment(2), alice));\n    assertEquals(receipt.value, 3n);\n\n    // mine a block with multiple transactions\n    const receipts = chain.mine(\n      txOk(counter.increment(2), alice),\n      txOk(counter.decrement(1), alice)\n    );\n    const [increment, decrement] = receipts;\n    assertEquals(decrement.value, 4n);\n\n    // Call a read-only function\n    // similar to Clarinet\'s `chain.callReadOnlyFn(...).expectOk()`\n    const currentCount = chain.rovOk(counter.readCounter());\n    assertEquals(currentCount, 3n);\n  },\n});\n')),(0,r.kt)("h2",{id:"differences-between-clarigen-and-clarinet"},"Differences between Clarigen and Clarinet"),(0,r.kt)("p",null,"In Clarinet, the result of a mined block isn't strongly typed. When using Clarigen, a transaction receipt's ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," is a native JavaScript type, which is strongly typed. Otherwise, the other properties of a transaction receipt (like ",(0,r.kt)("inlineCode",{parentName:"p"},"events"),") are the same."),(0,r.kt)("p",null,"Additionally, to ensure strong typing, transactions are specified as 'spread arguments' instead of an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// in Clarinet:\nconst block = chain.mineBlock([\n  Tx.contractCall(...)\n]);\nblock.receipts[0].value; // string, like `(ok u4)`\n\n// in Clarigen:\nconst block = chain.mineBlock(\n  txOk(contract.fn(...), sender)\n);\nblock.receipts[0].value; // native type, like `4n`, `true`, "string", etc.\n')),(0,r.kt)("h2",{id:"api"},"API"),(0,r.kt)("h3",{id:"contractsfactory"},(0,r.kt)("inlineCode",{parentName:"h3"},"contractsFactory")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"contractsFactory"),' is a helper function that consumes your "simnet" information, which includes all of your contracts and your accounts from ',(0,r.kt)("inlineCode",{parentName:"p"},"settings/Devnet.toml"),". Usually, you'll provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"simnet")," variable that is generated by Clarigen."),(0,r.kt)("p",null,"It returns an object where each key is the name of one of your contracts, and the value for that key is a 'contract factory' to let you invoke function calls."),(0,r.kt)("p",null,'For example, assume your project has two contracts, named "counter" and "token":'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { counter, token } = contractsFactory(simnet);\n\n// generate a contract call payload:\ncounter.increment(2);\n// includes a full identifier for the contract:\ntoken.identifier;\n// includes the raw ABI (interface) of that contract\ntoken.fungible_tokens[0].name;\n")),(0,r.kt)("h3",{id:"factory"},(0,r.kt)("inlineCode",{parentName:"h3"},"factory")),(0,r.kt)("p",null,"If you're using ",(0,r.kt)("inlineCode",{parentName:"p"},"Clarinet.test")," inside your test files to define tests, Clarigen provides a handy helper that provides a similar API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tests/contract_test.ts"',title:'"tests/contract_test.ts"'},'// import from the Clarigen package:\nimport { factory } from "https://deno.land/x/clarigen/src/index.ts";\n// import from your auto-generated code:\nimport { simnet } from "./clarigen.ts";\n\nconst { contracts, test } = factory(simnet);\n\ntest({\n  name: "My Clarigen test",\n  fn(chain, accounts) {\n    // tests go here:\n  },\n});\n')),(0,r.kt)("h3",{id:"chain"},(0,r.kt)("inlineCode",{parentName:"h3"},"chain")),(0,r.kt)("p",null,"Clarigen provides a ",(0,r.kt)("inlineCode",{parentName:"p"},"Chain")," interface that wraps around Clarinet's ",(0,r.kt)("inlineCode",{parentName:"p"},"Chain")," API, while providing extra helpers and type-safe functions."),(0,r.kt)("h3",{id:"tx-builders"},"Transaction builders (",(0,r.kt)("inlineCode",{parentName:"h3"},"tx"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"txOk"),", and ",(0,r.kt)("inlineCode",{parentName:"h3"},"txErr"),")"),(0,r.kt)("p",null,'When creating transactions in your unit tests, they must be wrapped in a "transaction builder". Each of these builders accepts two arguments: a contract call and a sender.'),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"txOk")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"txErr"),' are a way to easily specify the "expected" outcome of the transaction. When writing tests, you usually are expecting either ',(0,r.kt)("inlineCode",{parentName:"p"},"ok")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"err"),', so these helpers are what you should usually use. When using these builders, if the transaction results in the opposite type, an error will be thrown. Additionally, these helpers automatically "pull" the resulting ',(0,r.kt)("inlineCode",{parentName:"p"},"value")," from the response of the transaction and are automatically typed."),(0,r.kt)("p",null,"As an example, imagine the following Clarity function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (fn (is-ok bool))\n  (if is-ok\n    (ok true)\n    (err u1)\n  )\n)\n")),(0,r.kt)("p",null,"Here's how you would use that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=tests/contract_test.ts",title:"tests/contract_test.ts"},"// expect ok, `receipt.value` is type `boolean`\ntxOk(contract.fn(true), sender);\n// expect err, `receipt.value` is type `bigint`\ntxErr(contract.fn(false), sender);\n\n// these will throw an error:\ntxOk(contract.fn(false), sender);\ntxErr(contract.fn(true), sender);\n\n// `receipt.value` is type `Response<boolean, bigint>`\ntx(contract.fn(true), sender);\n")),(0,r.kt)("h3",{id:"chainmineblock"},(0,r.kt)("inlineCode",{parentName:"h3"},"chain.mineBlock")),(0,r.kt)("p",null,"Similar to Clarinet's ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.mineBlock"),", except with strict types. Transactions must be built with ",(0,r.kt)("a",{parentName:"p",href:"#tx-builders"},"transaction builders"),"."),(0,r.kt)("h3",{id:"chainmine"},(0,r.kt)("inlineCode",{parentName:"h3"},"chain.mine")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"chain.mine")," is shorthand for ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.mineBlock(...).receipts"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// these two are the same\nchain.mineBlock(...).receipts;\nchain.mine(...);\n")),(0,r.kt)("h3",{id:"chainmineone"},(0,r.kt)("inlineCode",{parentName:"h3"},"chain.mineOne")),(0,r.kt)("p",null,"Shorthand for ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.mine(...).receipts[0]"),";"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// these two are the same\nchain.mine(...).receipts[0];\nchain.mineOne(...);\n")),(0,r.kt)("h3",{id:"chaintx-chaintxok-and-chaintxerr"},(0,r.kt)("inlineCode",{parentName:"h3"},"chain.tx"),", ",(0,r.kt)("inlineCode",{parentName:"h3"},"chain.txOk"),", and ",(0,r.kt)("inlineCode",{parentName:"h3"},"chain.txErr")),(0,r.kt)("p",null,"Shorthand for ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.mineOne(tx|txOk|txErr(...))"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// these two are the same:\nchain.mineOne(txOk(contract.fn(), sender));\nchain.txOk(contract.fn(), sender);\n")),(0,r.kt)("h3",{id:"read-only-function-calls"},"Read-only function calls"),(0,r.kt)("p",null,"Clarigen provides helper functions to make strongly typed read-only function calls."),(0,r.kt)("h4",{id:"chainro"},(0,r.kt)("inlineCode",{parentName:"h4"},"chain.ro")),(0,r.kt)("p",null,"Similar to Clarinet's ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.callReadOnlyFn"),", but with stronger types on the resulting value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// In Clarinet:\nconst result = chain.callReadOnlyFn(...);\nresult.value; // string, like `(ok u4)`\n\n// highlight-start\n// In Clarigen\nconst result = chain.ro(contract.fn());\nresult.value; // native type, like `4n`, `true`, or `"string"`\n')),(0,r.kt)("h4",{id:"chainrov"},(0,r.kt)("inlineCode",{parentName:"h4"},"chain.rov")),(0,r.kt)("p",null,"Shorthand for ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.ro(...).value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// these two are the same:\nchain.ro(contract.getNum()).value;\nchain.rov(contract.getNum());\n")),(0,r.kt)("h4",{id:"chainrovok-and-chainroverr"},(0,r.kt)("inlineCode",{parentName:"h4"},"chain.rovOk")," and ",(0,r.kt)("inlineCode",{parentName:"h4"},"chain.rovErr")),(0,r.kt)("p",null,"When the result of a read-only function call is a ",(0,r.kt)("inlineCode",{parentName:"p"},"response"),", these helpers assert that the response is either ",(0,r.kt)("inlineCode",{parentName:"p"},"ok")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"err")," and return the inner value. These function very similarly to ",(0,r.kt)("inlineCode",{parentName:"p"},"txOk")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"txErr"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// assume response type is `(response bool uint)`\n\n// returns `boolean`\nchain.rovOk(contract.fn(true));\n// returns `bigint`\nchain.rovErr(contract.fn(false));\n")),(0,r.kt)("h3",{id:"accounts"},"Accounts"),(0,r.kt)("p",null,"Clarigen compiles your Devnet accounts ahead of time. This allows you to access your types with static type safety."),(0,r.kt)("p",null,"You can access your accounts in two ways: as an object, and as a ",(0,r.kt)("inlineCode",{parentName:"p"},"Map"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface is included to provide an API most similar to Clarinet's API."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{label:"object",value:"object",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// import it directly from your Clarigen types:\nimport { accounts } from "./clarigen.ts";\n\nconst alice = accounts.wallet_1.address;\nconst deployer = accounts.deployer.address;\n'))),(0,r.kt)(o.Z,{label:"Map",value:"map",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { factory, txOk } from "https://deno.land/x/clarigen/src/index.ts";\nimport { simnet } from "./clarigen.ts";\n\nconst { test } = factory(simnet);\n\ntest({\n  name: "my test",\n  fn(chain, accounts) {\n    const alice = accounts.get("wallet_1").address;\n    // or shorthand version:\n    const deployer = accounts.addr("deployer");\n  },\n});\n')))),(0,r.kt)("h3",{id:"chainfromsimnet"},(0,r.kt)("inlineCode",{parentName:"h3"},"Chain.fromSimnet")),(0,r.kt)("p",null,"Some developers prefer to use a different test runner than the ",(0,r.kt)("inlineCode",{parentName:"p"},"Clarinet.test")," interface. In that situation, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"Chain.fromSimnet")," to instantiate the chain manually."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=tests/bdd_test.ts",title:"tests/bdd_test.ts"},'import { assertEquals } from "https://deno.land/std@0.90.0/testing/asserts.ts";\nimport { accounts, simnet } from "./clarigen.ts";\nimport {\n  Chain,\n  contractsFactory,\n  factory,\n  txOk,\n} from "https://deno.land/x/clarigen/src/index.ts";\nimport {\n  beforeAll,\n  describe,\n  it,\n  run,\n} from "https://deno.land/x/dspec@v0.2.0/mod.ts";\n\nconst { counter } = contractsFactory(simnet);\n\ndescribe("BDD-style testing", () => {\n  let chain: Chain;\n  beforeAll(() => {\n    chain = Chain.fromSimnet(simnet).chain;\n  });\n  const alice = accounts.wallet_1.address;\n\n  it("can increment", () => {\n    const receipt = chain.mineOne(txOk(counter.increment(2), alice));\n    const count = chain.rovOk(counter.readCounter());\n    assertEquals(count, 3n);\n    assertEquals(receipt.value, 3n);\n  });\n\n  it("can decrement", () => {\n    const count = chain.rovOk(counter.readCounter());\n    assertEquals(count, 3n);\n    const receipt = chain.mineOne(txOk(counter.decrement(1n), alice));\n    assertEquals(receipt.value, 2n);\n    assertEquals(chain.blockHeight, 3);\n  });\n});\n\nrun();\n')))}m.isMDXComponent=!0}}]);