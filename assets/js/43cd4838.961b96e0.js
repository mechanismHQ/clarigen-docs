"use strict";(self.webpackChunkheynky=self.webpackChunkheynky||[]).push([[658],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=r,h=u["".concat(c,".").concat(m)]||u[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7035:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3,sidebar_label:"Core Concepts",toc_max_heading_level:4},i="Core Concepts",l={unversionedId:"core-concepts",id:"core-concepts",title:"Core Concepts",description:"Clarigen can be broken down into two things:",source:"@site/docs/core-concepts.md",sourceDirName:".",slug:"/core-concepts",permalink:"/docs/core-concepts",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,sidebar_label:"Core Concepts",toc_max_heading_level:4}},c={},s=[{value:"How it works",id:"how-it-works",level:2},{value:"The <code>ContractCall</code> type",id:"the-contractcall-type",level:3},{value:"Generated files",id:"generated-files",level:2},{value:"Clarigen base directory",id:"clarigen-base-directory",level:3},{value:"Top-level <code>index.ts</code>",id:"top-level-indexts",level:3},{value:"<code>contracts</code>",id:"contracts",level:4},{value:"<code>accounts</code>",id:"accounts",level:4},{value:"Contract types",id:"contract-types",level:4},{value:"Contract directories",id:"contract-directories",level:3},{value:"<code>index.ts</code>",id:"indexts",level:4},{value:"<code>${contractName}Contract</code>",id:"contractnamecontract",level:5},{value:"<code>${contractName}Info</code>",id:"contractnameinfo",level:5},{value:"<code>types.ts</code>",id:"typests",level:4},{value:"<code>abi.ts</code>",id:"abits",level:4}],p={toc:s};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"core-concepts"},"Core Concepts"),(0,r.kt)("p",null,"Clarigen can be broken down into two things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"set of libraries")," for interacting with Clarity contracts in a type-safe, boilerplate-reduced way, in multiple different environments."),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("strong",{parentName:"li"},"code generator")," that generates files and Typescript types relating to your Clarity contracts.")),(0,r.kt)("h2",{id:"how-it-works"},"How it works"),(0,r.kt)("p",null,"The magic behind Clarigen starts with the fact that any Clarity contract can be represented as a machine-readable interface, exposed in JSON format. In other blockchains, this is commonly referred to as an ABI. The interface for a contract looks something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "functions": [\n    {\n      "name": "decrement",\n      "access": "public",\n      "args": [],\n      "outputs": {\n        "type": {\n          "response": {\n            "ok": "int128",\n            "error": "none"\n          }\n        }\n      }\n    }\n  ]\n}\n')),(0,r.kt)("p",null,'Because we can get this interface for every single Clarity contract, we can depend on it and use it as a way to transform "JS native" code into Clarity function calls. For example, the above function ',(0,r.kt)("inlineCode",{parentName:"p"},"decrement")," has zero arguments, and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"(response int none)"),' Clarity type. That means we can write a JS "transformer" that knows how to convert JavaScript values (like ',(0,r.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean"),") into Clarity values (",(0,r.kt)("inlineCode",{parentName:"p"},"uint"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"bool"),") and back."),(0,r.kt)("h3",{id:"the-contractcall-type"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"ContractCall")," type"),(0,r.kt)("p",null,"Probably the most important concept to know is that, when you use Clarigen, you're calling simple functions that generate a ",(0,r.kt)("inlineCode",{parentName:"p"},"ContractCall"),". Here's what that type looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export interface ContractCall<T> {\n  function: ClarityAbiFunction;\n  nativeArgs: any[];\n  functionArgs: ClarityValue[];\n  contractAddress: string;\n  contractName: string;\n}\n")),(0,r.kt)("p",null,'When you\'re interacting with your contracts, the "JS native" function you call will return a ',(0,r.kt)("inlineCode",{parentName:"p"},"ContractCall")," by transforming the arguments you've passed. For example, imagine this contract function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-read-only (add-four (n uint))\n  (+ n u4)\n)\n")),(0,r.kt)("p",null,"Clarigen will generate the TypeScript interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"addFour: (n: number | bigint) => ContractCalls.ReadOnly<bigint>;\n")),(0,r.kt)("p",null,"When we actually call this function, it will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const txPayload = myContract.addFour(5);\n// `txPayload` looks like:\n{\n  function: {\n    name: 'add-four',\n    args: [{ name: 'n', type: 'uint128' }],\n    outputs: { type: 'uint128 }\n  },\n  nativeArgs: [5],\n  functionArgs: [uintCV(5)],\n  contractAddress: 'ST123...',\n  contractName: 'my-contract-name',\n}\n")),(0,r.kt)("p",null,"With this JSON-compatible object, we have enough information to make a contract call (whether read-only or public) in any environment. From here, it's just a matter of creating adapters for each environment."),(0,r.kt)("p",null,'Clarigen includes various adapters, or "providers", for each environment (unit tests, node.js, and web). This "provider pattern" is a tried-and-true way to build out a flexible pattern that can be widely used.'),(0,r.kt)("h2",{id:"generated-files"},"Generated files"),(0,r.kt)("p",null,"When you use Clarigen to generate files, it creates TypeScript files in the following structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"clarigenDir # Root directory for clarigen\n\u2514\u2500\u2500 index.ts\n\u2514\u2500\u2500 contractDir # a different folder for each contract\n   \u251c\u2500\u2500 index.ts\n   \u251c\u2500\u2500 types.ts\n   \u2514\u2500\u2500 abi.ts\n")),(0,r.kt)("h3",{id:"clarigen-base-directory"},"Clarigen base directory"),(0,r.kt)("p",null,"All generated code lives under this directory. By default, this will be ",(0,r.kt)("inlineCode",{parentName:"p"},"src/clarigen"),". You can customize this in your ",(0,r.kt)("inlineCode",{parentName:"p"},"clarigen.config.json")," file, using the ",(0,r.kt)("inlineCode",{parentName:"p"},"outputDir")," option."),(0,r.kt)("p",null,"Don't edit these files - they'll be overwritten each time Clarigen generates files. It's also best not to add any files under this folder."),(0,r.kt)("h3",{id:"top-level-indexts"},"Top-level ",(0,r.kt)("inlineCode",{parentName:"h3"},"index.ts")),(0,r.kt)("p",null,"Most of the time, you'll only need to import from this file itself. This file exports:"),(0,r.kt)("h4",{id:"contracts"},(0,r.kt)("inlineCode",{parentName:"h4"},"contracts")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"contracts"),' is an object where each key is the camel-case name of a contract, and the associated value is the "info" or metadata for that contract. Clarigen\'s libraries are built to consume this object for easy deployment and usage.'),(0,r.kt)("h4",{id:"accounts"},(0,r.kt)("inlineCode",{parentName:"h4"},"accounts")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"accounts")," is simply a version of your ",(0,r.kt)("inlineCode",{parentName:"p"},"Devnet.toml")," file, converted to Typescript so that you can use it at runtime. Typically, you'll only use this in your unit tests, where you'll want to bootstrap your test environment with a specific deployer and STX balances."),(0,r.kt)("p",null,"Each key in ",(0,r.kt)("inlineCode",{parentName:"p"},"accounts")," is the name of that account. The value of each account includes ",(0,r.kt)("inlineCode",{parentName:"p"},"mnemonic"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"balance"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"address"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export const accounts = {\n  deployer: {\n    mnemonic: "twice kind ...",\n    balance: 100000000000000n,\n    address: "ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM",\n  },\n  account_1: {}, // etc\n};\n')),(0,r.kt)("h4",{id:"contract-types"},"Contract types"),(0,r.kt)("p",null,"You can import each of your contracts Typescript interfaces from here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import type { CounterContract, TokenContract } from "./clarigen";\n')),(0,r.kt)("h3",{id:"contract-directories"},"Contract directories"),(0,r.kt)("p",null,"For each contract in your project, you'll have a folder with files related to that contract. The name of this folder is the camel-case version of your contract's name, as specified in ",(0,r.kt)("inlineCode",{parentName:"p"},"Clarinet.toml"),"."),(0,r.kt)("h4",{id:"indexts"},(0,r.kt)("inlineCode",{parentName:"h4"},"index.ts")),(0,r.kt)("p",null,"The key exports of this file are:"),(0,r.kt)("h5",{id:"contractnamecontract"},(0,r.kt)("inlineCode",{parentName:"h5"},"${contractName}Contract")),(0,r.kt)("p",null,"This is a builder function that allows you to pass the deployer address and contract name of this file, and it returns a version of your contract that you'll use to make contract calls."),(0,r.kt)("h5",{id:"contractnameinfo"},(0,r.kt)("inlineCode",{parentName:"h5"},"${contractName}Info")),(0,r.kt)("p",null,"This is an object with metadata that Clarigen uses within internal libraries. You mostly won't use this export directly. It includes the default deployer address, file location, contract ABI, and the builder contract function (described above)."),(0,r.kt)("h4",{id:"typests"},(0,r.kt)("inlineCode",{parentName:"h4"},"types.ts")),(0,r.kt)("p",null,"This is a pure TypeScript file - it doesn't export any values you can use at runtime. It only exports the generated TypeScript interface that allows you to interact with contracts in a type-safe and JS-native way."),(0,r.kt)("p",null,"The interface looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export interface CounterContract {\n  // public functions:\n  increment: () => ContractCalls.Public<bigint, bigint>;\n\n  // functions that have arguments:\n  incrementMany: (\n    count: number | bigint\n  ) => ContractCalls.Public<bigint, bigint>;\n\n  // read-only functions:\n  getCounter: () => ContractCalls.ReadOnly<bigint>;\n\n  // maps too!\n  idToUserMap: () => ContractCalls.Map<bigint, string>;\n}\n")),(0,r.kt)("h4",{id:"abits"},(0,r.kt)("inlineCode",{parentName:"h4"},"abi.ts")),(0,r.kt)("p",null,"The only export here is a ",(0,r.kt)("inlineCode",{parentName:"p"},"ClarityAbi")," object, which is the exact same ABI you'd get from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/stacks-network/stacks-blockchain/blob/master/docs/rpc-endpoints.md#get-v2contractsinterfacestacks-addresscontract-name"},"contract interface")," RPC method. Clarigen mostly uses this under the hood, but it's also helpful for use at runtime in certain situations."))}d.isMDXComponent=!0}}]);