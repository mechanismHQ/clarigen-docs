"use strict";(self.webpackChunkheynky=self.webpackChunkheynky||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>y});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),y=a,h=d["".concat(l,".").concat(y)]||d[y]||u[y]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={sidebar_position:1,sidebar_label:"Introduction",slug:"/"},o="Clarigen",s={unversionedId:"intro",id:"intro",title:"Clarigen",description:"Clarigen is a developer tool that automatically generates TypeScript-friendly clients that can interact with Clarity smart contracts.",source:"@site/docs/intro.md",sourceDirName:".",slug:"/",permalink:"/docs/",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,sidebar_label:"Introduction",slug:"/"},sidebar:"clarigen",next:{title:"Getting Started",permalink:"/docs/getting-started"}},l={},c=[{value:"Why?",id:"why",level:2},{value:"How it works",id:"how-it-works",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"clarigen"},"Clarigen"),(0,a.kt)("p",null,"Clarigen is a developer tool that automatically generates TypeScript-friendly clients that can interact with ",(0,a.kt)("a",{parentName:"p",href:"https://clarity-lang.org"},"Clarity")," smart contracts."),(0,a.kt)("p",null,"Clarigen is built to work alongside the libraries and tooling you already use. For unit tests, it works perfectly with ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hirosystems/clarinet"},"Clarinet"),". When you're building web apps or node.js code, it works seamlessly with ",(0,a.kt)("a",{parentName:"p",href:"https://micro-stacks.dev"},(0,a.kt)("inlineCode",{parentName:"a"},"micro-stacks")),"."),(0,a.kt)("p",null,"If you'd like to get started using Clarigen in your project, head over to the ",(0,a.kt)("a",{parentName:"p",href:"./docs/getting-started"},"getting started with Clarigen")," page."),(0,a.kt)("h2",{id:"why"},"Why?"),(0,a.kt)("p",null,"When you're building Clarity contracts, and Clarity apps, there is a ton of boilerplate code that you need to write. Similarly, you need to use a different library, with a different API, depending on if you're writing tests, web apps, or node.js code."),(0,a.kt)("p",null,"On the other hand, Clarity's designs mean that we shouldn't have to write lots of boilerplate. Clarity code is fully type-safe, and isn't compiled, so it's easy to generate a type interface for every single Clarity contract."),(0,a.kt)("p",null,"Clarigen is designed to harness Clarity's architecture and type safety to remove any and all boilerplate in your JavaScript projects. Ultimately, it makes Clarity development much more productive and easy."),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("p",null,"The magic behind Clarigen starts with the fact that any Clarity contract can be represented as a machine-readable interface, exposed in JSON format. In other blockchains, this is commonly referred to as an ABI. The interface for a contract looks something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "functions": [\n    {\n      "name": "decrement",\n      "access": "public",\n      "args": [],\n      "outputs": {\n        "type": {\n          "response": {\n            "ok": "int128",\n            "error": "none"\n          }\n        }\n      }\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"Clarigen will take the JSON interface for each of your projects, lightly annotate it, and generate a TypeScript interface inside your project. When you're writing JS code (whether for testing or building apps), Clarigen's libraries will utilize these types to make interacting with contracts a breeze."),(0,a.kt)("p",null,"The end result is that you'll be able to write code that looks like native JavaScript, but is converted under-the-hood to proper Clarity types."),(0,a.kt)("p",null,"Here's an example of what your code will look like when using Clarigen. This is an example of writing unit tests with Clarinet."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="tests/counter_test.ts"',title:'"tests/counter_test.ts"'},'// import helpers from the Clarigen package:\nimport { factory, txOk } from "https://deno.land/x/clarigen/src/index.ts";\n// import from your auto-generated code:\nimport { simnet } from "./clarigen.ts";\nimport { assertEquals } from "https://deno.land/std@0.90.0/testing/asserts.ts";\n\n// helper function to "setup" the test environment\nconst { contracts, test } = factory(simnet);\n\n// "counter" is the name of our contract\nconst { counter } = contracts;\n\ntest({\n  name: "Counter test",\n  fn(chain, accounts) {\n    // similar to `accounts.get(\'wallet_1\').address`;\n    const alice = accounts.addr("wallet_1");\n\n    // mine a block with a single transaction\n    // similar to `const [receipt] = chain.mineBlock(...).receipts;`\n    const receipt = chain.mineOne(txOk(counter.increment(2), alice));\n    assertEquals(receipt.value, 3n);\n\n    // mine a block with multiple transactions\n    const receipts = chain.mine(\n      txOk(counter.increment(2), alice),\n      txOk(counter.decrement(1), alice)\n    );\n    const [increment, decrement] = receipts;\n    assertEquals(decrement.value, 4n);\n\n    // Call a read-only function\n    // similar to Clarinet\'s `chain.callReadOnlyFn(...).expectOk()`\n    const currentCount = chain.rovOk(counter.readCounter());\n    assertEquals(currentCount, 3n);\n  },\n});\n')),(0,a.kt)("p",null,"Clarity has it\u2019s own set of ",(0,a.kt)("a",{parentName:"p",href:"https://docs.stacks.co/docs/write-smart-contracts/clarity-language/language-types"},"built-in types"),", but Clarigen will convert them to JavaScript native values behind the scenes. This way, you can pass arguments and check results just like you would with any JavaScript library."))}u.isMDXComponent=!0}}]);